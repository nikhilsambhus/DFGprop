#include "DFGAnaly.h"
using namespace std;
DFGAnaly::DFGAnaly() {}
DFGAnaly::DFGAnaly(DAG grph) {
	gp = grph;
}
void DFGAnaly::topoSortHelper(uint32_t node, vector<bool> &visited, stack<uint32_t> &st) {
	visited[node] = true;
	list<Node> succs;
	gp.getSuccessors(node, succs);
	for(Node nd : succs) {
		uint32_t ndId = nd.getID();
		if(visited[ndId] == false) {
			topoSortHelper(ndId, visited, st);
		}
	}
	st.push(node);
}

vector<uint32_t> DFGAnaly::topoSort() {
	vector<uint32_t> order;
	stack<uint32_t> stNodes;

	vector<bool> visited;
	for(uint32_t i = 0; i < gp.getNumNodes(); i++) {
		visited.push_back(false);
	}

	for(uint32_t i = 0; i < gp.getNumNodes(); i++) {
		if(visited[i] == false) {
			topoSortHelper(i, visited, stNodes);
		}
	}

	while(!stNodes.empty()) {
		order.push_back(stNodes.top());
		stNodes.pop();
	}

	return order;
}
uint32_t DFGAnaly::assignTime(vector<uint32_t> &topOrder, vector<int32_t> &timeSt) {
	for(uint32_t i = 0; i < gp.getNumNodes(); i++) {
		timeSt.push_back(-1);
	}

	int32_t timeMax = 0;
	for(uint32_t n : topOrder) {
		list<Node> preds;
		gp.getPredecessors(n, preds);
		int32_t max = 0;
		string label = gp.findNode(n)->getLabel();
		for(Node prNode : preds) {
			uint32_t id = prNode.getID();
			if(timeSt[id] == -1) {
				cout << "Error, predecessor time cannot be -1\n";
				exit(-1);
			}
			else if(max < timeSt[id]) {
				max = timeSt[id];
			}
		}
		if((label.find("load") != std::string::npos)) {
			int stride = stoi(label.substr(label.find(";") + 1, label.length()));
			if(stride >= STRIDE_MIN) {
				timeSt[n] = max;
			}
			else {
				timeSt[n] = max + 1;//nodeWts["load"];
			}
		}
		else if((label.find("store") != std::string::npos)) {
			int stride = stoi(label.substr(label.find(";") + 1, label.length()));
			if(stride >= STRIDE_MIN) {
				timeSt[n] = max;
			}
			else {
				timeSt[n] = max + 1; //nodeWts["store"];
			}
		}
		else {
			timeSt[n] = max + 1;//nodeWts[label];
		}

		if(timeMax < timeSt[n]) {
			timeMax = timeSt[n];
		}
	}

	return timeMax;
}
double DFGAnaly::getParallelism() {
	vector<uint32_t> topOrder = topoSort();
	vector<int32_t> timeSt; 
	uint32_t timeMax = assignTime(topOrder, timeSt);
	/*cout << "Time Max is " << timeMax << endl;
	cout << "Topological sort order is\n";
	for(uint32_t n : topOrder) {
		cout << gp.findNode(n)->getLabel() << " has time " << timeSt[n] << endl;
	}
	cout << endl;
	*/
	double total = 0;
	for(uint32_t i = 0; i <= timeMax; i++) {
		total+= count(timeSt.begin(), timeSt.end(), i);	
	}
	
	return total/timeMax;
}

uint32_t DFGAnaly::criticalPathLen() {
	vector<uint32_t> topOrder = topoSort();
	vector<int32_t> timeSt; 
	uint32_t timeMax = assignTime(topOrder, timeSt);
	return timeMax;
}

